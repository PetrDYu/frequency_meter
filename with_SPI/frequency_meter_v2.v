
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module frequency_meter_v2(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO,
	
	inout				 [35:0]		GPIO_1
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

//определения для старого решения

/*reg [30:0] base, freq0, freq1;
wire freq_in = CLOCK_50;

reg freq_div;

reg [3:0] HEX_in_0, HEX_in_1, HEX_in_2, HEX_in_3, HEX_in_4, HEX_in_5;*/

//определения для нового решения

wire [31:0] freq_b, freq_i;
wire clk_in, clk_base;
wire cout_i;
reg cout_b = 0, sclr_b = 0, aclr_i = 0;

wire clk_0_0, clk_0_1, clk_0_2, clk_0_3, clk_0_4, clk_0_5, clk_0_6, clk_0_7, clk_0_8;
wire clk_1_0, clk_1_1, clk_1_2, clk_1_3, clk_1_4, clk_1_5, clk_1_6, clk_1_7, clk_1_8;

//assign clk_base = SW[0] ? clk_1_0 : clk_0_0;
//assign clk_in = SW[0] ? (SW[1] ? (SW[2] ? (SW[3] ? clk_1_8 : clk_1_7) : (SW[3] ? clk_1_6 : clk_1_5)) : (SW[2] ? (SW[3] ? clk_1_4 : clk_1_3) : (SW[3] ? clk_1_2 : clk_1_1))) : 
								//(SW[1] ? (SW[2] ? (SW[3] ? clk_0_8 : clk_0_7) : (SW[3] ? clk_0_6 : clk_0_5)) : (SW[2] ? (SW[3] ? clk_0_4 : clk_0_3) : (SW[3] ? clk_0_2 : clk_0_1)));

parameter freq_base = 31'd200_000_000;//MHz

//=======================================================
//  Structural coding
//=======================================================

// Старое неработающее решение

/*initial
begin
	
	base = 31'b0;
	freq0 = 31'b01;
	freq1 = 31'b01;
	freq_div = 1'b0;
	
end

always @(posedge CLOCK_50)
begin
	
	base = base + 1'b1;
	if (base == 31'd50000000)
	begin
	
		base = 31'b0;
		freq_div = freq_div + 1'b1;
		
	end
		
	
end

always @(posedge freq_in)
begin
	
	if (freq_div == 1'b0)
		freq0 = freq0 + 1'b1;
	else
		freq1 = freq1 + 1'b1;
	
	if (base == 31'd50000000)
	begin

		if (freq_div == 1'b0)
		begin
			freq0 = 31'b01;
			HEX_in_0 = (freq1 / 31'd1000) % 4'd10;
			HEX_in_1 = (freq1 / 31'd10000) % 4'd10;
			HEX_in_2 = (freq1 / 31'd100000) % 4'd10;
			HEX_in_3 = (freq1 / 31'd1000000) % 4'd10;
			HEX_in_4 = (freq1 / 31'd10000000) % 4'd10;
			HEX_in_5 = (freq1 / 31'd100000000) % 4'd10;
		end
		else
		begin
			freq1 = 31'b01;
			HEX_in_0 = (freq0 / 31'd1000) % 4'd10;
			HEX_in_1 = (freq0 / 31'd10000) % 4'd10;
			HEX_in_2 = (freq0 / 31'd100000) % 4'd10;
			HEX_in_3 = (freq0 / 31'd1000000) % 4'd10;
			HEX_in_4 = (freq0 / 31'd10000000) % 4'd10;
			HEX_in_5 = (freq0 / 31'd100000000) % 4'd10;
		end
		
		
	end
	
end

*/

SEG_HEX u0
(
	
	.iDIG(1'b0),
	.oHEX_D(HEX0),
	.lock(CLOCK_50)
	
);

SEG_HEX u1
(
	
	.iDIG(1'b0),
	.oHEX_D(HEX1),
	.lock(CLOCK_50)
	
);

SEG_HEX u2
(
	
	.iDIG(1'b0),
	.oHEX_D(HEX2),
	.lock(CLOCK_50)
	
);

SEG_HEX u3
(
	
	.iDIG(1'b0),
	.oHEX_D(HEX3),
	.lock(CLOCK_50)
	
);

SEG_HEX u4
(
	
	.iDIG(freq_base /31'd10_000_000 % 31'd10),
	.oHEX_D(HEX4),
	.lock(CLOCK_50)
	
);

SEG_HEX u5
(
	
	.iDIG(freq_base / 31'd100_000_000),
	.oHEX_D(HEX5),
	.lock(CLOCK_50)
	
);

/*always @(negedge KEY[1] or negedge KEY[2])
begin
	
	if (KEY[1] == 1'b0) freq_base = 31'd700_000_000;
	if (KEY[2] == 1'b0) freq_base = 31'd200_000_000;
	
end*/

PLL_temp pll_0
(
	
	.refclk(CLOCK_50),
	.rst(~KEY[0]),
	.outclk_0(clk_0_0),
	.outclk_1(clk_0_1),
	.outclk_2(clk_0_2),
	.outclk_3(clk_0_3),
	.outclk_4(clk_0_4),
	.outclk_5(clk_0_5),
	.outclk_6(clk_0_6),
	.outclk_7(clk_0_7),
	.outclk_8(clk_0_8),
	
);

PLL_temp_1 pll_1
(
	
	.refclk(CLOCK_50),
	.rst(~KEY[0]),
	.outclk_0(clk_1_0),
	.outclk_1(clk_1_1),
	.outclk_2(clk_1_2),
	.outclk_3(clk_1_3),
	.outclk_4(clk_1_4),
	.outclk_5(clk_1_5),
	.outclk_6(clk_1_6),
	.outclk_7(clk_1_7),
	.outclk_8(clk_1_8),
	
);

assign clk_base = clk_1_0;
assign clk_in = GPIO_1[11];

always @(posedge clk_base)
begin
	
	if (freq_b == freq_base - 1) cout_b = 1;
	else cout_b = 0;
	
	if (freq_b == freq_base)
	begin
	
		sclr_b = 1;
		aclr_i = 1;
		
	end
		
	if (freq_b == 1'b0)
	begin
	
		sclr_b = 0;
		aclr_i = 0;
		
	end
	
end


//Счётчик опорной частоты

Counter b_c
(
	
	.aclr(1'b0),
	.clock(clk_base),
	.sclr(sclr_b),
	.q(freq_b)
	
);

//Счётчик измеряемой частоты

Counter i_c
(
	
	.aclr(aclr_i),
	.clock(clk_in),
	.sclr(1'b0),
	.cout(cout_i),
	.q(freq_i)
	
);

// SPI

reg start, rstb, aset;

wire done;
reg [7:0] tdata = 8'b0;

wire [3:0] i;
reg [31:0] freq_mem;

wire ss, sck, sdin, sdout;

assign ss = GPIO[3];
assign sck = GPIO[1];
assign sdin = GPIO[5];
assign GPIO[7] = sdout;

initial
begin

	rstb = 1'b0;
	start = 1'b1;
	aset = 1'b1;	
end


always @(posedge cout_b)
begin
	
	aset = 1'b0;
	rstb = 1'b1;
	freq_mem = freq_i;
	
end

always @(posedge done)
begin

	start = 1'b0;
	case (i)
		0: tdata = freq_mem[7 : 0];
		1: tdata = freq_mem[15 : 8];
		2: tdata = freq_mem[23 : 16];
		3: tdata = freq_mem[31 : 24];
	endcase
	
end

Counter_4 count_n_freq
 (
	
	.clock(done),
	.q(i),
	.aset(aset)
	
 );
 
assign LEDR[1] = ~GPIO[3];
assign LEDR[2] = GPIO[1];
 
 spi_slave spi
(
	
	.rstb(rstb),
	.ten(1'b1),
	.tdata(tdata),
	.mlb(1'b1),
	.ss(ss),
	.sck(sck),
	.sdin(sdin),
	.sdout(sdout),
	.done(done),
	
);

endmodule
